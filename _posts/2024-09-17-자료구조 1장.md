---
layout: single
title:  "자료구조 1장"
categories: 자료구조
tag: [Database] 
author_profile: false # 블로그 글 좌측 프로필 표시 여부 
search: true # 해당 글 검색 가능 여부
---

> Fundamentals of Data Structures in C++, Horowitz, Sahni and Menta 2nd Edition

# 제 1장 기본개념

## 대형 컴퓨터 시스템(SW)

### 대형 컴퓨터 프로그램
: 소프트웨어도 하드웨어처럼 부품들로 구성함으로써 고장난 부품만 고치고 교환하는 등, 유지보수의 비용을 줄임 

- 복잡하게 상호작용하는 부품들로 구성된 시스템
- 시스템 생명주기

### 대형 컴퓨터 시스템의 설계 및 구현 방법론
- 데이터 추상화
- 알고리즘 명세
- 성능분석과 측정
    - 성능분석: 실제로 프로그램을 실행하지 않고 미리 예측하는 것
    - 측정: 출시 전 실제로 실행하여 테스트하는 것

## 시스템 생명 주기(System Life Cycle)

### 요구사항(requirement)
: 클라이언트가 제작자에게 요구하는 것
- 프로젝트들의 목적을 정의한 명세들의 집합
- 입력과 출력에 관한 정보를 기술

### 분석(analysis)
- 문제들을 다룰 수 있는 작은 단위로 세분화
- 상향식(bottom-up) 접근 방법 ex) C
- 하향식(top-down) 접근 방법(객체지향 방식) ex) C++

### 설계(design)
- 추상 데이터 타입 생성
- 알고리즘 명세와 설계기법을 고려해야함

### 정제와 코딩(refinement and coding)
- 데이터 객체에 대한 표현 선택(프로그램 언어를 선택)
- 수행되는 연산에 대한 알고리즘 작성

### 검증(verification)
- 정확성 증명: 수학적 기법들을 이용해서 증명
- 테스트: 프로그램의 성능을 검사하고 정확한 수행을 검증
- 오류 제거: 독립적 단위로 테스트 후 전체 시스템으로 통합

검증단계에서 오류를 발견했을 때 그 오류의 종류에 따라 시스템 생명 주기 상의 어디로든 다시 되돌아갈 수 있다.

## 객체지향 설계

### 구조적 프로그래밍 설계와의 비교
- 유사점
    - 분할-정복 기법: 복잡한 문제를 여러개의 단순한 부분 작업으로 나누어 개별적으로 해결함
- 차이점
    - 과제 분할 방법

## 알고리즘적 분해와 객치지향적 분해

### 알고리즘적 분해(함수적 분해)
- 고전적 프로그래밍 기법
- 소프트웨어를 기능적 모듈(함수)로 분해(bottom-up 방식)
- Pascal의 프로시저, FORTRAN의 서브프로그램, C의 함수...

### 객체지향적 분해
- 응용 분야의 개체를 모델링하는 객체의 집합(top-down 방식)
- 소프트웨어의 재사용성 조장, 용이
- 각 객체만 수정하면 되므로 변화에 유연하다.
- 직관적 -> 오류발생 가능성이 낮음

## 객체지향 프로그래밍의 기본 정의, 개념

### 객체(object)
- 계산을 수행하고 상태를 갖는 개체
- 데이터 + 절차적 요소
    - 데이터: 상태 저장을 위한 멤버변수
    - 절차적 요소: 멤버변수를 사용하는 함수

### 객체지향 프로그래밍(object-oriented programming)
- 객체는 기본적인 구성단위
- 각 객체는 어떤 타입(클래스)의 인스턴스
- 클래스는 상속관계로 연관됨

### 객체지향 언어(object- oriented language)
- 객체 지원
- 모든 객체는 클래스에 속함
- 상속 지원

### 객체기반 언어
- 객체와 클래스는 지원하되, 상속은 지원하지 않음

## 데이터 추상화와 캡슐화

### 데이터 캡슐화(data encapsulation)
- 정보를 은닉함
    - 정보: 외부로부터 데이터객체의 자세한 구현
    - 정보를 은닉하는 이유: 사용자가 굳이 알 필요가 없기 때문

> ex) 자동차를 운전하는 운전자는 자동차의 작동원리를 굳이 알 필요가 없다.

### 데이터 추상화(data abstraction)
-  객체의 명세와 구현을 분리
    - 명세: 무엇(what)
    - 구현: 어떻게(how)

> ex) C++에서 헤더파일을 #include를 사용하여 파일에 포함시킴으로써 해당 기능(무엇)을 사용한다는 것을 알 수 있지만 그 기능의 실제 구현은 나와있지 않다.

### 데이터 캡슐화, 추상화의 장점
- **소프트웨어 개발의 간소화:** 복잡한 작업을 부분 작업으로 분해
- **테스트와 디버깅:** 각 부분 작업을 독자적으로 테스트, 디버깅 가능

>ex) C언어는 디버그하려면 코드를 모두 읽어야 하지만, C++(객체지향언어)은 각각의 클래스가 연결된 형태므로 각각 디버그가 가능하다.

- **재사용성:** 자료구조에 대한 코드와 연산을 추출해서 다른 소프트웨어 시스템에서도 사용가능하다.
- **데이터 타입의 표현에 대한 수정:** 데이터 타입의 내부 구현에 직접 접근하는 연산들만 수정

## 데이터 타입

### 데이터 타입: 객체(object)들과 이 객체들에 대한 연산(operation)의 집합

### C++의 데이터 타입
- 기본 데이터 타입: double, int float, char...
- 파생 데이터 타입: 포인터 타입, 참조 타입
- 데이터를 묶어주는 구조: 배열(array), 구조(struct), 클래스(class)
- 사용자 정의 데이터 타입(사용자가 정의한 클래스)

### 추상 데이터 타입(abstract data Type: ADT)
: 객체와 연산에 대한 **명세**가 객체의 **표현**과 연산의 **구현**으로부터 분리된 방식으로 구성된 데이터 타입

## C++의 매개변수 전달

### 값(value)에 의한 전달
- 전달된 객체는 실인자의 값을 복사하여 함수에 전달됨(실인자에 영향X)
- 값을 복사해서 함수에 전달되므로 실인자로 제공되는 변수가 함수에 의해 변경되지 않음

### 참조(reference)에 의한 전달
- 값을 복사하여 전달하는 게 아닌, 실인자로 제공되는 변수의 주소를 함수에 전달(실인자에 영향O)
- 함수에서 실인자의 주소에 직접 접근하므로 실인자로 제공되는 변수가 함수에 의해 변경된다.
> 값에 의한 전달은 값을 복사해서 전달하므로 안전하지만 메모리사용, 속도저하의 단점이 존재한다.

### 상수 참조
- 인자 변경 불가
- const T & a

### 배열은 참조로 전달

## C++의 다중화(overloading)

### 연산자 다중화(operator overloading)
: 연산자(+, -, ==, <<, >> 등등)를 여러 데이터타입(사용자정의 클래스도 가능)에 적용 가능하다.

### 함수 다중화(function overloading)
: 함수의 인자 리스트가 다르기만 하면 같은 이름을 가진 함수가 둘 이상 존재 가능

&nbsp; ![함수 다중화](/assets/images/CS/함수다중화.png)

## 예외 발생, 처리
- 오류와 다른 특별한 조건이 발생했음을 알리는 데 사용 **(오류 아님 주의!!)**
- 다양한 예외 각각에 대해 예외 클래스를 정의

&nbsp; ![예외발생](/assets/images/CS/예외발생.png)
- 예외 처리는 try 블록에 발생될 수 있는 예외를 포함시켜서 처리
- try 블록 뒤에는 0개 이상의 catch 블록

## 알고리즘 명세

### 알고리즘(algorithm)
: 특정 작업을 수행하는 명령어들의 **유한집합**

### 알고리즘의 요건
- 입력: 외부에서 제공되는 데이터가 0개 이상
- 출력: 적어도 한 개 이상의 결과 생성
- 명확성: 각 명령은 명확하고 모호하지 않아야함
- 유한성: 알고리즘을 수행하면 어떤 경우에도 반드시 종료
- 유효성: 반드시 실행 가능해야함

## 선택정렬(selection sort)
- n >= 1 개의 서로 다른 정수의 집합을 정렬
- "정렬되지 않은 정수들중에서 가장 작은 값을 찾아서 정렬된 리스트 다음 자리에 놓는다."(자연어로 기술한것)

&nbsp; ![선택정렬](/assets/images/CS/선택정렬.png)

1) 두 번쨰 for문을 통해, 배열 a의 a[i] 부터 a[n-1] 중 가장 작은 정수를 찾는다. <br>

2) 그 정수를 배열에서 정렬되지 않은 값들 중 첫 번째 인덱스에 위치한 값과 바꾼다. <br>

ex <br>
5 2 4 1 3 <br>
1 2 4 5 3 <br>
1 2 3 5 4 <br>
1 2 3 4 5 <br>
이런 식으로 정렬이 된다.

## 이원탐색
- **이미 정렬된 배열** a[0] ~ a[n-1] 에서 찾고자 하는 값 x 의 인덱스를 반환
- 초기값 left = 0, right = n-1, middle = (left + right) / 2 로 설정
- a[middle]과 x를 비교
    - x < a[middle] 이면, right = middle - 1
    - x > a[middle] 이면, left = middle + 1
    - x == a[middle] 이면, middle 반환(찾고자하는 값의 인덱스)

&nbsp; ![alt text](image.png)

ex <br>
a[] = 10 20 30 40 50 60 70 일 때, x = 60 의 인덱스를 찾고자 한다면

1) left = 0, right = 6, middle = (0 + 6) / 2 = 3

2) x > a[3] 이므로, <br>
left = 4, middle = (4 + 6) / 2 = 5

3) x = a[5] 이므로, <br>
middle 반환, 즉 5 반환

## 재귀(Recursive) 알고리즘

### 수행이 완료되기 전에 자기 자신을 다시 호출
- 직접 재귀: 함수가 그 수행이 완료되기 전에 자기 자신을 다시 호출
- 간접 재귀: 호출 함수를 다시 호출하게 되어 있는 다른 함수를 호출
